#pragma once

/**
 * \defgroup point c.point
 * \brief This smart contract represents functions providing creation and circulation of points in a community, as well as their conversion to system tokens.
 * \details The main token on the commun platform is CMN token. A prerequisite for creating a community on this platform is the creation of a unique community point that will be used to reward users, leaders, and pay for services. Each community has its own point with its own name, which can be exchanged for CMN token or redeemed by performing the reverse operation. Point is not a token and cannot be used in exchange trading. Points are used as coins to encourage community members and applied only within the community, while CMN tokens can be circulated outside it within the commun application.

 * User creating a community has to transfer a certain amount of CMN tokens to the community account. These tokens are reserved for their subsequent exchange for points. The minimum number of CMN to create any community is one.

 * Buying or selling community points on CMN tokens is done through the community account. When buying points, a user spends CMN tokens, which are reserved and stored on the community account balance. If the purchased number of points is not on the balance, their missing number will be generated by \a c.point contract. When selling points, they are withdrawn from circulation and user is paid corresponding amount of CMN. Exchange rate of community point to CMN token is adjusted when a number of points in circulation changes. Correction takes place in accordance with the Bancor algorithm implemented in the contract.

 * Current information about community points is stored in DB. Information about transfer operations on points is sent to the Event Engine in form of events.

 * <b>Safe as a way to save funds</b>

 * Smart contract implements “safe” functionality. The safe allows a user to manipulate funds in order to preserve them, namely to lock funds and withdrawal operations on them, including transfer, selling points to buy tokens. If safe is enabled, Access to funds is possible if safe is enabled and they have been unlocked by the safe owner.
 
 * \note
 * Safe locking operations do not affect “frozen” funds.

 * Smart contract supports the following operations applicable to the safe: [enablesafe][1], [disablesafe][2], [unlocksafe][3], [locksafe][4], [modifysafe][5], [applysafemod][6], [cancelsafemod][7], [globallock][8]. 

 * At first, a safe owner should enable his/her safe via calling [enablesafe][1]. This action allows the owner to set initial amount of unlocked points in the safe (\a unlock parameter). Later the owner can call [unlocksafe][3] to increase unlocked amount.

 * The actions [enablesafe][1], [locksafe][4], [cancelsafemod][7] and [globallock][8] are executed instantly, while a delay is set for other ones. The delay is set in order to prevent the use of funds by an attacker.

 * For actions performed with a delay, a \a mod is created in a special table. The \a mod indicates an intention to perform specific action related to a safe.
 
 * There are three types of the \a mod operations:
 * - [unlocksafe][3] creates \a mod to unlock funds
 * - [modifysafe][5] creates \a mod to change safe settings
 * - [disablesafe][2] creates \a mod to disable safe.

 * The safe has two configurable parameters - a pause (delay in the operation) and a trusted account, which is a structure field that can be either empty name ("") or an account name. Empty name means no trusted account set.

 * If a "delayed" action has the trusted account signature, this action will be executed without creating a \a mod, and therefore without delay. Having such signature guarantees authenticity of action that it is not performed by a fraudster.
 
 * User has two ways for doing that one:
 * - get a signature of trusted account to instantly perform an action
 * - create a \a mod and after some time get a signature of trusted account. Once the action is signed, it is immediately executed without waiting for the delay expires.

 * There are two almost independent parts: per-point safes and global lock. Both of them limit the balance reductions (transfer out, retire withdraw), yet allow to freeze the points (create gems/vote).

 * - __1__ User can enable and set up safes for each point he has. He sets an unlocked limit (let it be "0") and a delay, which is necessary before the safe can be modified (unlock more points, change settings, disable the safe). After enabling safe, the account can reduce his balance up to unlocked value prone to decrease each time he reduces the balance. If there are no more unlocked points or action requires more points than unlocked, it will fail.

 * User calls the [unlocksafe][3] action so that he is able to unlock more points. This puts him into the delayed \a mod, which can be canceled anytime or applied after a delay. Straight after applying, the unlocked amount is increased by the value stored in \a mod.

 * User can "lock" some points instantly in order to reduce the unlocked value (execute [locksafe][4] action). To modify the safe options, user may call the [modifysafe][5] action, which creates delayed \a mod to apply after delay. Similar delayed \a mod created to disable safe ([disablesafe][2] action).

 * User can set trusted account in safe options. This allows to apply any of the delayed actions or \a mod instantly in the event of action being signed by both balance owner and trusted account.

 * - __2__ Global lock locks all the account's balances for an indicated amount of time. This allows locking points after recovery to make sure malicious individuals can't steal them.

 * [globallock][8] has a higher priority than safe unlocked points.

 * Active global lock also prevents users from applying delayed \a mods without a trusted signature.

 * [1]: @ref commun::point::enablesafe
 * [2]: @ref commun::point::disablesafe
 * [3]: @ref commun::point::unlocksafe
 * [4]: @ref commun::point::locksafe
 * [5]: @ref commun::point::modifysafe
 * [6]: @ref commun::point::applysafemod
 * [7]: @ref commun::point::cancelsafemod
 * [8]: @ref commun::point::globallock
 */

/**
 * \defgroup point_class Contract description
 * \ingroup point
 * \details The class contains actions for introducing points inside a community. All transactions for purchase and sale of points are carried out through the account \a c.point, on which the commun application is deployed.
 */

/**
 * \defgroup point_tables DB Stored structures
 * \ingroup point
 * \details Structures representing actual data related to points, stored in DB.
 */

/**
 * \defgroup point_events Events
 * \ingroup point
 * \details Events sent to the Event Engine by the \a c.point contract.
 */
